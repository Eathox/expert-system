use crate::*;
use permutation_iter::PermutationIter;

use anyhow::{anyhow, Context, Result};
use std::borrow::Borrow;
use std::collections::{HashMap, HashSet};
use std::fmt;
use std::iter::Peekable;
use std::rc::Rc;
use Token::*;

#[derive(Debug, Copy, Clone)]
pub enum Direction {
    UniDirectional,
    BiDirectional,
}

#[derive(Debug, Copy, Clone)]
pub enum Token {
    Implicator(Direction),
    Operator(char),
    Parenthesis(char),
    Bool(bool),
}

#[derive(Default)]
pub struct RuleParser;

impl<'a> RuleParser {
    pub fn new() -> Self {
        RuleParser {}
    }

    fn get_direction<I>(&mut self, lexer: &mut I, c: char) -> Result<Direction>
    where
        I: Iterator<Item = char>,
    {
        if let Some(next) = lexer.next() {
            match (c, next) {
                ('=', '>') => Ok(Direction::UniDirectional),
                ('<', '=') => match lexer.next() {
                    Some('>') => Ok(Direction::BiDirectional),
                    _ => Err(anyhow!("Unable to finish lexing implicator")),
                },
                _ => Err(anyhow!("Unable to finish lexing implicator")),
            }
        } else {
            Err(anyhow!("Unable to finish lexing implicator"))
        }
    }

    pub fn tokenize(&mut self, input: &str) -> Result<Vec<Token>> {
        let mut lexer = input.chars();
        let mut token_list: Vec<Token> = Vec::new();
        while let Some(c) = lexer.next() {
            match c {
                '(' | ')' => token_list.push(Parenthesis(c)),
                '!' | '+' | '|' | '^' => token_list.push(Operator(c)),
                '=' | '<' => token_list.push(Implicator(self.get_direction(&mut lexer, c)?)),
                '0' => token_list.push(Bool(false)),
                '1' => token_list.push(Bool(true)),
                c if c.is_whitespace() => {}
                _ => return Err(anyhow!("Unexpected character: {}", c)),
            }
        }
        Ok(token_list)
    }

    fn get_rule<I>(&mut self, token_list: &mut Peekable<I>) -> Result<bool>
    where
        I: Iterator<Item = &'a Token>,
    {
        let antecedent = self.get_operator(token_list)?;
        if let Some(implicator) = token_list.next() {
            let consequent = self.get_operator(token_list)?;
            match implicator {
                Implicator(direction) => match direction {
                    Direction::UniDirectional => Ok(!antecedent | consequent),
                    Direction::BiDirectional => Ok(antecedent == consequent),
                },
                _ => unreachable!(),
            }
        } else {
            Err(anyhow!("No implicator found"))
        }
    }

    fn get_operator<I>(&mut self, token_list: &mut Peekable<I>) -> Result<bool>
    where
        I: Iterator<Item = &'a Token>,
    {
        let mut node = self.get_factor(token_list);
        while let Some(Operator(_)) = token_list.peek() {
            node = match token_list.next() {
                Some(Operator('+')) => Ok(node? & self.get_factor(token_list)?),
                Some(Operator('|')) => Ok(node? | self.get_factor(token_list)?),
                Some(Operator('^')) => Ok(node? ^ self.get_factor(token_list)?),
                _ => unreachable!(),
            }
        }
        node
    }

    fn get_factor<I>(&mut self, token_list: &mut Peekable<I>) -> Result<bool>
    where
        I: Iterator<Item = &'a Token>,
    {
        match token_list.next() {
            Some(Parenthesis('(')) => {
                let res = self.get_operator(token_list);
                match token_list.next() {
                    Some(Parenthesis(')')) => res,
                    _ => Err(anyhow!("Missing closing parenthesis")),
                }
            }
            Some(Operator('!')) => Ok(!self.get_factor(token_list)?),
            Some(Bool(b)) => Ok(*b),
            Some(t) => Err(anyhow!("Invalid factor token '{:?}'", t)),
            None => Err(anyhow!("Unexpected end of token list")),
        }
    }

    pub fn evaluate(&mut self, input: &str) -> Result<bool> {
        let token_list = self
            .tokenize(input)
            .context(format!("Failed to tokenize input: '{}'", input))?;
        self.get_rule(&mut token_list.iter().peekable())
    }
}

// TruthTable struct holds the truth table data of an input rule.
// It can be constructed using a PermutationIter. Since the permutations generated by
// PermuationIter is always guaranteed to follow the same pattern, the order of the results
// implicitly holds the propositional data for each entry in the TruthTable. Example:
// `0 => 0` implies index 0b00, results[0]
// `0 => 1` implies index 0b01, results[1]
// `1 => 0` implies index 0b10, results[2]
// `1 => 1` implies index 0b11, results[3]
#[derive(Default, Eq, PartialEq, Hash, Clone)]
pub struct TruthTable {
    pub variables: Vec<char>,
    pub results: Vec<bool>,
}

impl TruthTable {
    pub fn new() -> Self {
        TruthTable {
            variables: Vec::new(),
            results: Vec::new(),
        }
    }
}

impl TryFrom<PermutationIter> for TruthTable {
    type Error = anyhow::Error;

    fn try_from(mut permutation_iter: PermutationIter) -> Result<Self, Self::Error> {
        let mut table = Self::new();
        let mut parser = RuleParser::new();
        for permutation in permutation_iter.by_ref() {
            table.results.push(
                parser
                    .evaluate(&permutation)
                    .context(format!("Failed to evaluate permutation {}", permutation))?,
            );
        }
        table.variables.append(&mut permutation_iter.variables);
        Ok(table)
    }
}

impl fmt::Debug for TruthTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let len = self.variables.len();
        for v in &self.variables {
            write!(f, "| {} ", v)?;
        }
        writeln!(f, "| = |")?;
        writeln!(f, "{}|", "|---".repeat(len + 1))?;
        for (i, result) in self.results.iter().enumerate() {
            for b in 0..len {
                write!(
                    f,
                    "| {} ",
                    if i & (1 << (len - 1 - b)) == 0 { 0 } else { 1 }
                )?
            }
            writeln!(f, "| {} |", if *result { 1 } else { 0 })?;
        }
        Ok(())
    }
}

// Structure that holds key pairs of identifier and all related truth tables.
#[derive(Default, Eq, PartialEq)]
pub struct RuleMap {
    map: HashMap<char, HashSet<Rc<TruthTable>>>,
}

impl RuleMap {
    // Inserts a new rule in the rulemap Ad-Hoc
    pub fn insert<T>(&mut self, rule: T) -> Result<()>
    where
        T: Borrow<str>,
    {
        let ptr = Rc::new(TruthTable::try_from(PermutationIter::new(rule))?);
        for v in ptr.variables.iter() {
            let tables = self
                .map
                .entry(*v)
                .or_insert_with(|| HashSet::from([Rc::clone(&ptr)]));
            tables.insert(Rc::clone(&ptr));
        }
        Ok(())
    }

    pub fn insert_vec<T>(&mut self, rules: Vec<T>) -> Result<()>
    where
        T: Borrow<str>,
    {
        for rule in rules.iter() {
            self.insert(rule.borrow())?
        }
        Ok(())
    }
}

impl<T> TryFrom<Vec<T>> for RuleMap
where
    T: Borrow<str>,
{
    type Error = anyhow::Error;

    fn try_from(rules: Vec<T>) -> Result<Self> {
        let rule_set = rules
            .into_iter()
            .map(|s| TruthTable::try_from(PermutationIter::new(s.borrow())))
            .collect::<Result<Vec<TruthTable>>>()
            .context("Unable to build RuleMap")?;
        let mut map = HashMap::new();
        for rule in rule_set.into_iter() {
            let ptr = Rc::new(rule);
            for v in ptr.variables.iter() {
                let tables = map
                    .entry(*v)
                    .or_insert_with(|| HashSet::from([Rc::clone(&ptr)]));
                tables.insert(Rc::clone(&ptr));
            }
        }
        Ok(RuleMap { map })
    }
}

impl fmt::Debug for RuleMap {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let mut map = self.map.iter().peekable();
        while let Some((k, v)) = map.next() {
            writeln!(f, "{}", k)?;
            let mut table = v.iter().peekable();
            while let Some(t) = table.next() {
                if map.peek().is_none() && table.peek().is_none() {
                    write!(f, "{:?}", t)?;
                } else {
                    writeln!(f, "{:?}", t)?;
                }
            }
        }
        Ok(())
    }
}

#[cfg(test)]
mod tests_rule_parser {
    use super::*;

    use anyhow::Result;
    use pretty_assertions::assert_eq;

    #[test]
    fn uni_directional() -> Result<()> {
        let mut parser = RuleParser::new();
        assert_eq!(parser.evaluate("1 => 0")?, false);
        assert_eq!(parser.evaluate("0 => 1")?, true);
        assert_eq!(parser.evaluate("1 => 1")?, true);
        assert_eq!(parser.evaluate("0 => 0")?, true);
        Ok(())
    }

    #[test]
    fn bi_directional() -> Result<()> {
        let mut parser = RuleParser::new();
        assert_eq!(parser.evaluate("1 <=> 0")?, false);
        assert_eq!(parser.evaluate("0 <=> 1")?, false);
        assert_eq!(parser.evaluate("1 <=> 1")?, true);
        assert_eq!(parser.evaluate("0 <=> 0")?, true);
        Ok(())
    }

    #[test]
    fn not() -> Result<()> {
        let mut parser = RuleParser::new();
        assert_eq!(parser.evaluate("!1 => 0")?, true);
        assert_eq!(parser.evaluate("!0 => 0")?, false);

        assert_eq!(parser.evaluate("1 => !1")?, false);
        assert_eq!(parser.evaluate("1 => !0")?, true);
        Ok(())
    }

    #[test]
    fn and() -> Result<()> {
        let mut parser = RuleParser::new();
        assert_eq!(parser.evaluate("1 + 1 => 0")?, false);
        assert_eq!(parser.evaluate("1 + 0 => 0")?, true);
        assert_eq!(parser.evaluate("0 + 1 => 0")?, true);
        assert_eq!(parser.evaluate("0 + 0 => 0")?, true);

        assert_eq!(parser.evaluate("1 => 1 + 1")?, true);
        assert_eq!(parser.evaluate("1 => 0 + 1")?, false);
        assert_eq!(parser.evaluate("1 => 1 + 0")?, false);
        assert_eq!(parser.evaluate("1 => 0 + 0")?, false);
        Ok(())
    }

    #[test]
    fn or() -> Result<()> {
        let mut parser = RuleParser::new();
        assert_eq!(parser.evaluate("1 | 1 => 0")?, false);
        assert_eq!(parser.evaluate("1 | 0 => 0")?, false);
        assert_eq!(parser.evaluate("0 | 1 => 0")?, false);
        assert_eq!(parser.evaluate("0 | 0 => 0")?, true);

        assert_eq!(parser.evaluate("1 => 1 | 1")?, true);
        assert_eq!(parser.evaluate("1 => 1 | 0")?, true);
        assert_eq!(parser.evaluate("1 => 0 | 1")?, true);
        assert_eq!(parser.evaluate("1 => 0 | 0")?, false);
        Ok(())
    }

    #[test]
    fn xor() -> Result<()> {
        let mut parser = RuleParser::new();
        assert_eq!(parser.evaluate("1 ^ 1 => 0")?, true);
        assert_eq!(parser.evaluate("1 ^ 0 => 0")?, false);
        assert_eq!(parser.evaluate("0 ^ 1 => 0")?, false);
        assert_eq!(parser.evaluate("0 ^ 0 => 0")?, true);

        assert_eq!(parser.evaluate("1 => 1 ^ 1")?, false);
        assert_eq!(parser.evaluate("1 => 1 ^ 0")?, true);
        assert_eq!(parser.evaluate("1 => 0 ^ 1")?, true);
        assert_eq!(parser.evaluate("1 => 0 ^ 0")?, false);
        Ok(())
    }

    #[test]
    fn parenthesis() -> Result<()> {
        let mut parser = RuleParser::new();
        assert_eq!(parser.evaluate("1 | 0 + 0 => 0")?, true);
        assert_eq!(parser.evaluate("(1 | 0) + 0 => 0")?, true);
        assert_eq!(parser.evaluate("1 | (0 + 0) => 0")?, false);
        assert_eq!(parser.evaluate("0 + 0 | 1 => 0")?, false);
        assert_eq!(parser.evaluate("(0 + 0) | 1 => 0")?, false);
        assert_eq!(parser.evaluate("0 + (0 | 1) => 0")?, true);

        assert_eq!(parser.evaluate("1 => 1 | 0 + 0")?, false);
        assert_eq!(parser.evaluate("1 => (1 | 0) + 0")?, false);
        assert_eq!(parser.evaluate("1 => 1 | (0 + 0)")?, true);
        assert_eq!(parser.evaluate("1 => 0 + 0 | 1")?, true);
        assert_eq!(parser.evaluate("1 => (0 + 0) | 1")?, true);
        assert_eq!(parser.evaluate("1 => 0 + (0 | 1)")?, false);
        Ok(())
    }

    #[test]
    fn error_empty() {
        let result = RuleParser::new().evaluate("");
        assert!(result.is_err());
        assert_eq!(
            result.unwrap_err().to_string(),
            "Unexpected end of token list"
        );
    }

    #[test]
    fn error_invalid_state() {
        let result = RuleParser::new().evaluate("A => Z");
        assert!(result.is_err());
        assert_eq!(
            result.unwrap_err().to_string(),
            "Failed to tokenize input: 'A => Z'"
        );
    }

    #[test]
    fn error_invalid_operator() {
        let result = RuleParser::new().evaluate("0 = 1");
        assert!(result.is_err());
        assert_eq!(
            result.unwrap_err().to_string(),
            "Failed to tokenize input: '0 = 1'"
        );
    }

    #[test]
    fn error_missing_operator_half() {
        let result = RuleParser::new().evaluate("0 | => 0");
        assert!(result.is_err());
        assert_eq!(
            result.unwrap_err().to_string(),
            "Invalid factor token 'Implicator(UniDirectional)'"
        );
    }

    #[test]
    fn error_missing_implicator() {
        let result = RuleParser::new().evaluate("0");
        assert!(result.is_err());
        assert_eq!(result.unwrap_err().to_string(), "No implicator found");
    }

    #[test]
    fn error_missing_parenthesis() {
        let result = RuleParser::new().evaluate("(0 => 0");
        assert!(result.is_err());
        assert_eq!(
            result.unwrap_err().to_string(),
            "Missing closing parenthesis"
        );
    }
}

#[cfg(test)]
mod tests_truth_table {
    use super::*;

    use anyhow::Result;
    use pretty_assertions::assert_eq;

    #[test]
    fn simple() -> Result<()> {
        let result = TruthTable::try_from(PermutationIter::new("A => Z"))?;
        assert_eq!(result.variables, vec!['A', 'Z']);
        assert_eq!(result.results, vec![true, true, false, true]);
        Ok(())
    }

    #[test]
    fn error_invalid_rule() {
        let result = TruthTable::try_from(PermutationIter::new("A = Z"));
        assert!(result.is_err());
        assert_eq!(
            result.unwrap_err().to_string(),
            "Failed to evaluate permutation 0 = 0"
        );
    }
}

#[cfg(test)]
mod tests_rule_map {
    use super::*;

    use anyhow::Result;
    use pretty_assertions::assert_eq;

    #[test]
    fn empty() -> Result<()> {
        Ok(())
    }

    #[test]
    fn insert() -> Result<()> {
        Ok(())
    }

    #[test]
    fn insert_vec() -> Result<()> {
        Ok(())
    }
}
